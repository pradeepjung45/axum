use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use sqlx::FromRow;
use uuid::Uuid;

// ============================================================================
// USER MODEL
// ============================================================================
// This represents a user in our system. It matches the 'users' table in the database.
// 
// Why do we need this?
// - To store user information (email, password, name)
// - To authenticate users when they login
// - To link wallets and transactions to specific users

#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct User {
    pub id: Uuid,                    // Unique identifier (auto-generated)
    pub email: String,               // User's email (must be unique)
    pub password_hash: String,       // Hashed password (NEVER store plain passwords!)
    pub full_name: String,           // User's full name
    pub created_at: DateTime<Utc>,   // When the account was created
    pub updated_at: DateTime<Utc>,   // When the account was last updated
}

// This is what we receive when a user wants to register
// Notice: NO password_hash, NO id, NO timestamps - those are generated by the system
#[derive(Debug, Deserialize)]
pub struct CreateUserRequest {
    pub email: String,
    pub password: String,            // Plain password (we'll hash it before storing)
    pub full_name: String,
}

// This is what we receive when a user wants to login
#[derive(Debug, Deserialize)]
pub struct LoginRequest {
    pub email: String,
    pub password: String,
}

// This is what we send back after successful login
#[derive(Debug, Serialize)]
pub struct LoginResponse {
    pub token: String,               // JWT token for authentication
    pub user: UserResponse,          // User info (without sensitive data)
}

// This is a "safe" version of User - without the password hash
// We send this to the client so they never see the password hash
#[derive(Debug, Serialize, Deserialize)]
pub struct UserResponse {
    pub id: Uuid,
    pub email: String,
    pub full_name: String,
    pub created_at: DateTime<Utc>,
}

// Convert from User to UserResponse (removes password_hash)
impl From<User> for UserResponse {
    fn from(user: User) -> Self {
        UserResponse {
            id: user.id,
            email: user.email,
            full_name: user.full_name,
            created_at: user.created_at,
        }
    }
}

// ============================================================================
// WALLET MODEL
// ============================================================================
// This represents a user's wallet. Each user has one wallet to store money.
//
// Why do we need this?
// - To track how much money each user has
// - To ensure users can't spend more than they have
// - To support multiple currencies (though we'll use USD for now)

#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct Wallet {
    pub id: Uuid,                    // Unique identifier
    pub user_id: Uuid,               // Which user owns this wallet
    pub balance: rust_decimal::Decimal, // Current balance (uses Decimal for precision with money)
    pub currency: String,            // Currency type (USD, EUR, etc.)
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

// Response when client asks for wallet info
#[derive(Debug, Serialize)]
pub struct WalletResponse {
    pub id: Uuid,
    pub balance: rust_decimal::Decimal,
    pub currency: String,
}

impl From<Wallet> for WalletResponse {
    fn from(wallet: Wallet) -> Self {
        WalletResponse {
            id: wallet.id,
            balance: wallet.balance,
            currency: wallet.currency,
        }
    }
}

/// Request to deposit money
#[derive(Debug, Deserialize)]
pub struct DepositRequest {
    pub amount: rust_decimal::Decimal,
}

/// Request to withdraw money
#[derive(Debug, Deserialize)]
pub struct WithdrawRequest {
    pub amount: rust_decimal::Decimal,
}

/// Request to transfer money
#[derive(Debug, Deserialize)]
pub struct TransferRequest {
    pub recipient_email: String,
    #[serde(deserialize_with = "deserialize_decimal_from_string")]
    pub amount: rust_decimal::Decimal,
}

/// Custom deserializer for Decimal from form string
fn deserialize_decimal_from_string<'de, D>(deserializer: D) -> Result<rust_decimal::Decimal, D::Error>
where
    D: serde::Deserializer<'de>,
{
    use serde::de::Error;
    let s = String::deserialize(deserializer)?;
    s.parse::<rust_decimal::Decimal>()
        .map_err(|e| Error::custom(format!("Invalid decimal: {}", e)))
}


// ============================================================================
// TRANSACTION MODEL
// ============================================================================
// This represents a financial transaction (deposit, withdrawal, transfer)
//
// Why do we need this?
// - To keep a record of all money movements
// - To track transaction status (pending, completed, failed)
// - For audit trails and user transaction history

#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct Transaction {
    pub id: Uuid,
    pub wallet_id: Uuid,             // Which wallet this transaction belongs to
    pub transaction_type: String,    // "DEPOSIT", "WITHDRAWAL", or "TRANSFER"
    pub amount: rust_decimal::Decimal,
    pub description: Option<String>, // Optional note about the transaction
    pub status: String,              // "PENDING", "COMPLETED", or "FAILED"
    pub created_at: DateTime<Utc>,
}

// Request to create a new transaction
#[derive(Debug, Deserialize)]
pub struct CreateTransactionRequest {
    pub transaction_type: String,    // DEPOSIT, WITHDRAWAL, TRANSFER
    pub amount: rust_decimal::Decimal,
    pub description: Option<String>,
}

// Response with transaction details
#[derive(Debug, Serialize)]
pub struct TransactionResponse {
    pub id: Uuid,
    pub transaction_type: String,
    pub amount: rust_decimal::Decimal,
    pub description: Option<String>,
    pub status: String,
    pub created_at: DateTime<Utc>,
}

impl From<Transaction> for TransactionResponse {
    fn from(tx: Transaction) -> Self {
        TransactionResponse {
            id: tx.id,
            transaction_type: tx.transaction_type,
            amount: tx.amount,
            description: tx.description,
            status: tx.status,
            created_at: tx.created_at,
        }
    }
}
